[视频](https://www.bilibili.com/list/watchlater?oid=113557693859593&bvid=BV1RsBZYxEvw&spm_id_from=333.1007.top_right_bar_window_view_later.content.click)
#### <b>整体架构</b>
##### <b>所含组件</b>
1. ThreadPool类： 线程池对象
2. Thread类：线程封装类
3. PoolMode：线程池模式枚举
4. Task类：任务抽象基类，用户任务继承这个类，可以自定义任务处理，含有run()抽象方法

#### <b>一些实现问题</b>
1. 为什么任务队列需要用智能指针而不是裸指针？因为不确定传入的任务的生命周期
2. 对生产者消费者模型的条件变量个数？可以参考信号量，分别为生产者和消费者各自定义一个，表示任务队列不满和不空
3. 为了在创建线程的时候对线程的运行先后顺序相对公平，先创建线程对象再统一启动
4. 线程类需要访问线程池中的私有对象，所以需要将线程函数定义在线程池内，通过函数包装器和lambda传递给线程类（教程中使用std::bind，但现代c++建议使用lambda替代bind）。为什么不用友元，猜测是为了防止破坏封装
5. 当任务队列满，用户进程在提交处阻塞一秒钟，则给其返回一个错误(任务降级)，这就是notEmpty信号量的作用


#### <b>一些问题</b>
##### <b>线程是不是越多越好？</b>
1. 线程的创建和销毁都是非常贵的操作
2. 线程栈会占用大量内存
3. 过多线程导致的线程上下文切换过于频繁
4. 过多线程同时唤醒导致系统锯齿状负载或瞬时负载过高（同一时间很多io准备好了）

线程数量一般按照cpu核心数量来确定

##### <b>线程池fixed模式和cached模式</b>
1. fixed模式：

    线程池中线程数量固定
2. cached模式：

    线程池中线程数量随线程池负载增大而增大，当线程空闲超过一定事件后将线程关闭

##### <b>线程同步</b>
###### <b>线程互斥</b>
条件：查看代码是否存在竞态条件，即代码在多线程下以不同顺序执行会不会出现不一样的结果，应保证临界区的原子性

使用互斥锁或者atomic原子类型解决

乐观锁try_lock和owns_lock， 悲观锁（也就是普通上锁操作）
###### <b>线程通信</b>
1. 条件变量：
    
    可以用于表示在一个线程所执行的任务在另一线程之后，需要等待某些条件成立的情况，条件不成立时线程等待，先决条件执行完毕，条件成立后使用notify对正在等待的线程进行通知和唤醒

    为什么条件变量使用unique_lock? 因为这个可以手动加锁解锁，而lock_guard不行

    条件变量执行过程：先加锁保护条件的计算和临界资源，然后释放锁阻塞当前线程，被唤醒后再加锁检查条件（防止虚假唤醒）

2. 信号量

    可以看作资源计数大于1的互斥锁，多元信号量直接对应操作系统中涉及的PV操作，二元信号量就是资源为1的信号量，使用aquire操作表示P，release操作表示V
    mutex的加锁和解锁只能出现在一个线程中，二元信号量的aquire和release可以出现在不同线程中

